# -*- coding: utf-8 -*-
"""Fusion_Layer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fR2fZ15Z_hKQTA2CWd5sNyIFVlAw7c8z

<a href="https://colab.research.google.com/github/alexander-harmaty/Breast-Cancer-Prognosis-Prediction/blob/main/fusion_layer.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

<a href="https://colab.research.google.com/" alt="Open In Colab"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# **Environment Setup and Imports**
"""

import pickle
import numpy as np
import pandas as pd
from collections import Counter
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.metrics import confusion_matrix, classification_report, roc_auc_score
import tensorflow as tf
from tensorflow.keras import Input, Model
from tensorflow.keras.layers import (
    Dense, Dropout, BatchNormalization,
    Concatenate, Multiply, Activation
)

"""# **Data Preprocessing**

## *Data Loading*
"""

# --- Data Loading & Alignment ---
with open('rnn_features.pkl','rb') as f: rnn = pickle.load(f)
with open('cnn_features.pkl','rb') as f: cnn = pickle.load(f)

df_rnn = pd.DataFrame(rnn['features'], index=rnn['ids'])
df_rnn['label'] = rnn['labels']
df_cnn = pd.DataFrame(cnn['features'], index=cnn['ids'])
df_cnn['label'] = cnn['labels']

common = df_rnn.index.intersection(df_cnn.index)
df_rnn = df_rnn.loc[common]
df_cnn = df_cnn.loc[common]

X_rnn = df_rnn.drop(columns='label').values
X_cnn = df_cnn.drop(columns='label').values
y     = df_rnn['label'].values

print('Feature shapes:', 'CNN:', X_cnn.shape, 'RNN:', X_rnn.shape)
print('Label distribution:', Counter(y))

"""## *Feature Merging*
single-input vs dual-input (choose which one to run)

plan:

*   single‑input fusion for baseline  
*   dual‑input gated fusion for fine tuning

### dual-input

## *Data Splitting*
"""

# --- Train/Validation/Test Split ---
Xc_train, Xc_temp, Xr_train, Xr_temp, y_train, y_temp = train_test_split(
    X_cnn, X_rnn, y,
    test_size=0.30, random_state=42, stratify=y
)
try:
    Xc_val, Xc_test, Xr_val, Xr_test, y_val, y_test = train_test_split(
        Xc_temp, Xr_temp, y_temp,
        test_size=0.50, random_state=42, stratify=y_temp
    )
except ValueError:
    Xc_val, Xc_test, Xr_val, Xr_test, y_val, y_test = train_test_split(
        Xc_temp, Xr_temp, y_temp,
        test_size=0.50, random_state=42
    )
print('Split sizes:', Counter(y_train), Counter(y_val), Counter(y_test))

"""# **Fusion Model**

## *Model Building*
"""

# --- Build gated fusion model ---
input_cnn = Input(shape=(X_cnn.shape[1],), name='cnn_in')
input_rnn = Input(shape=(X_rnn.shape[1],), name='rnn_in')

# Modality-specific projections
proj_cnn = Dense(128, activation='relu')(input_cnn)
proj_cnn = BatchNormalization()(proj_cnn)
proj_cnn = Dropout(0.3)(proj_cnn)

proj_rnn = Dense(128, activation='relu')(input_rnn)
proj_rnn = BatchNormalization()(proj_rnn)
proj_rnn = Dropout(0.3)(proj_rnn)

# Gating mechanism
gate = Concatenate()([proj_cnn, proj_rnn])
gate = Dense(128, activation='sigmoid', name='fusion_gate')(gate)

# Elementwise fusion
fused_cnn = Multiply()([gate, proj_cnn])
inv_gate = Activation('linear')(1.0 - gate)
fused_rnn = Multiply()([inv_gate, proj_rnn])
fused = tf.keras.layers.Add()([fused_cnn, fused_rnn])

# Joint MLP
x = Dense(64, activation='relu')(fused)
x = BatchNormalization()(x)
x = Dropout(0.3)(x)
x = Dense(32, activation='relu')(x)
x = Dropout(0.3)(x)
output = Dense(1, activation='sigmoid', name='out')(x)

model = Model(inputs=[input_cnn, input_rnn], outputs=output, name='gated_fusion_model')
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy', tf.keras.metrics.AUC(name='auc')])
model.summary()

"""## *Model Training*"""

# --- Training ---
history = model.fit(
    {'cnn_in': Xc_train, 'rnn_in': Xr_train},
    y_train,
    validation_data=({'cnn_in': Xc_val, 'rnn_in': Xr_val}, y_val),
    epochs=50, batch_size=32, verbose=2
)

"""## *Model Evaluation*"""

# --- Evaluation on Test Set ---
y_test_prob = model.predict({'cnn_in': Xc_test, 'rnn_in': Xr_test}).ravel()
y_test_pred = (y_test_prob >= 0.5).astype(int)
print('Confusion matrix on test set:')
print(confusion_matrix(y_test, y_test_pred))
print(classification_report(y_test, y_test_pred))
print('Test ROC AUC:', roc_auc_score(y_test, y_test_prob))

# --- Stratified K-Fold Cross-Validation ---
skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
auc_scores = []
for train_idx, test_idx in skf.split(X_cnn, y):
    Xc_tr, Xc_te = X_cnn[train_idx], X_cnn[test_idx]
    Xr_tr, Xr_te = X_rnn[train_idx], X_rnn[test_idx]
    y_tr, y_te = y[train_idx], y[test_idx]
    # Reinitialize model for each fold
    m = tf.keras.models.clone_model(model)
    m.compile(optimizer='adam', loss='binary_crossentropy')
    m.fit(
        {'cnn_in': Xc_tr, 'rnn_in': Xr_tr},
        y_tr,
        epochs=30, batch_size=32, verbose=0
    )
    prob = m.predict({'cnn_in': Xc_te, 'rnn_in': Xr_te}).ravel()
    auc_scores.append(roc_auc_score(y_te, prob))
print('Stratified K-Fold mean ROC AUC:', np.mean(auc_scores))